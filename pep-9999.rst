PEP: 9999
Title: Literal types
Author: Some subset of the mypy team
Status: Draft
Type: Standards Track
Python-Version: 3.8
Content-Type: text/x-rst
Created: 19-Nov-2018
Post-History: 19-Nov-2018

Abstract
========

This PEP proposes adding *Literal types* to the PEP 484 ecosystem.
Literal types indicate that some expression has literally a
specific value. For example, the following function will accept
only expressions that have literally the value "4"::

    from typing import Literal

    def accepts_only_four(x: Literal[4]) -> None:
        pass

    accepts_only_four(4)  # Type checker accepts
    accepts_only_four(8)  # Type checker rejects

**Note:** This PEP is still a very early draft: we plan
on refining it as we add work on the corresponding implementation
in mypy.

Motivation and Rationale
========================

Python has many APIs that return different types depending on the 
value of some argument provided. For example:

-  ``open(filename, mode)`` returns either ``IO[bytes]`` or ``IO[Text]``
   depending on whether the second argument is something like “r” or
   “rb”
-  ``subprocess.check_output(…)`` returns either bytes or text
   depending on whether the ``universal_newlines`` keyword argument is
   set to ``True`` or not.

This pattern is also fairly common in many popular 3rd party libraries.
For example, here are just two examples from pandas and numpy respectively:

-  ``pandas.concat(...)`` will return either ``Series`` or
   ``DataFrame`` depending on whether the ``axis`` argument is set to
   0 or 1.

-  ``numpy.unique`` will return either a single array or a tuple containing
   anywhere from two to four arrays depending on three boolean flag values.

The typing issue tracker contains some
`additional examples and discussion <typing-discussion_>`_.

There is currently no way of expressing the type signatures of these
functions: PEP 484 does not include any mechanism for writing signatures
where the return type varies depending on the value passed in. 
Note that this problem persists even if we redesign these APIs to
instead accept enums: ``MyEnum.FOO`` and ``MyEnum.BAR`` are both
considered to be of type ``MyEnum``.)

Currently, type checkers work around this limitation by adding ad-hoc
extensions for important builtins and standard library functions. For
example mypy comes bundled with a plugin that attempts to infer more
precise types for ``open(…)``. While this approach works for standard
library functions, it’s unsustainable in general: it’s not reasonable to
expect 3rd party library authors to maintain plugins for N different
type checkers, for example.

We propose to add *Literal types* to address the gaps listed above.

Specification
=============

Core Semantics
--------------

This section outlines the baseline behavior of literal types.

Core behavior
'''''''''''''

Literal types indicate a variable has a specific and
concrete value. For example, if we define some variable ``foo`` to have
type ``Literal[3]``, we are declaring that ``foo`` must be exactly equal
to ``3`` and no other value.

Given some value ``V`` that is a member of type ``T``, the type
``Literal[V]`` shall be treated as a subtype of ``T``. For example,
``Literal[3]`` is a subtype of ``int``.

All methods from the parent type will be directly inherited by the
literal type. So, if we have some variable ``foo`` of type ``Literal[3]``
it’s safe to do things like ``foo + 5`` since ``foo`` inherits int’s
``__add__`` method. The resulting type of ``foo + 5`` is ``int``.

This “inheriting” behavior is identical to how we handle NewTypes.

Equivalence of two Literals
'''''''''''''''''''''''''''

Two types ``Literal[A]`` and ``Literal[B]`` are equivalent when
both of the following conditions are true:

1. ``type(A) == type(B)``
2. ``A == B``

For example, ``Literal[20]`` and ``Literal[0x14]`` are equivalent.
However, ``Literal[0]`` and ``Literal[False]`` is *not* equivalent
despite that ``0 == False`` evaluates to 'true' at runtime: ``0``
has type ``int`` and ``False`` has type ``bool``.

Shortening unions of literals
'''''''''''''''''''''''''''''

Literals are parameterized with one or more value. When a Literal is
parameterized with more then one value, it's treated as exactly equivalent
to the union of those types. That is, ``Literal[V1, V2, V3]`` is equivalent
to ``Union[Literal[V1], Literal[V2], Literal[V3]]``.

This shortcut helps make writing signatures for functions that accept
many different literals more ergonomic — for example, functions like
``open(...)``::

   # Note: this is a simplification of the true type signature.
   _PathType = Union[str, bytes, int]

   @overload
   def open(path: _PathType, 
            mode: Literal["r", "w", "a", "x", "r+", "w+", "a+", "x+"],
            ) -> IO[Text]: ...
   @overload
   def open(path: _PathType, 
            mode: Literal["rb", "wb", "ab", "xb", "r+b", "w+b", "a+b", "x+b"],
            ) -> IO[bytes]: ...

   # Fallback overload for when the user isn't using literal types
   @overload
   def open(path: _PathType, mode: str) -> IO[Any]: ...

**Note:** Literals **must** be parameterized with at least one type.
Types like ``Literal[]`` or ``Literal`` are illegal.

Legal and illegal parameterizations
-----------------------------------

This section describes exactly which values may or may not parameterize 
a ``Literal[...]`` type.

Legal parameters for ``Literal`` at type check time
'''''''''''''''''''''''''''''''''''''''''''''''''''

``Literal`` may be parameterized with literal ints, native strings,
bools, Enum values, and ``None``. So for example, all of the following
would be legal::

   Literal[26]
   Literal[0x1A]  # Exactly equivalent to Literal[26]
   Literal["hello world"]
   Literal[True]
   Literal[Color.RED]  # Assuming Color is some enum
   Literal[None]

**Note:** The type ``Literal[None]`` is redundant in that the type
``None`` has only a single inhabitant. We nevertheless allow this 
for consistency and ease-of-use. For example, when writing a literal
with multiple parameters, it might look a little cleaner to do
``Literal[1, 2, 3, None]`` instead of ``Optional[Literal[1, 2, 3]]``.

Illegal parameters for ``Literal`` at type check time
'''''''''''''''''''''''''''''''''''''''''''''''''''''

The following are provisionally disallowed, mostly for
simplicity. We can consider adding these to the above list on a
case-by-case basis based on demand.

-  Explicit byte strings: e.g. ``Literal[b'foo']``.

-  Explicit unicode strings: e.g. ``Literal[u'foo']``.

-  Floats: e.g. ``Literal[3.14]``. Note: if we do decide to allow
   floats, we should likely disallow literal infinity and literal NaN.

-  Any: e.g. ``Literal[Any]`` Note: the semantics of what exactly
   ``Literal[Any]`` means would need to be clarified first.

-  Literal types themselves (or aliases to literal types). For example, if we
   create a type alias ``BasicIds = Literal[1, 2, 3]``, then perhaps
   ``Literal[100, BasicIds]`` should be treated as being equivalent to
   ``Literal[100, 1, 2, 3]``.

The following parameters are intentionally disallowed by design:

-  Arbitrary expressions like ``Literal[3 + 4]`` or
   ``Literal["foo".replace("o", "b")]``. Literal types are meant to be a
   minimal extension to the PEP 484 typing ecosystem and requiring type
   checkers to interpret potentially expressions inside types adds too
   much complexity. Also see `Rejected or out-of-scope ideas`_.

-  Complex numbers like ``Literal[4 + 3j]``, ``Literal[-4 + 2j]``, and
   ``Literal[5j]``. Types like ``Literal[4 + 3j]`` would violate the
   previous rule; it would then be consistent to also disallow types
   like ``Literal[4j]``.

-  Tuples containing valid literal types like ``Literal[(1, "foo", "bar")]``.
   The user could always express this type as
   ``Tuple[Literal[1], Literal["foo"], Literal["bar"]]`` instead. Also,
   tuples are likely to be confused with the ``Literal[1, 2, 3]``
   shortcut.

-  Mutable literal data structures like dict literals, list literals, or
   set literals: literals are always implicitly final and immutable. So,
   ``Literal[{"a": "b", "c": "d"}]`` would be disallowed.

-  Any other types: for example, ``Literal[MyTypedDict]``, or
   ``Literal[some_object_instance]`` are disallowed.
   This includes typevars: if ``T`` is a typevar,  ``Literal[T]`` is
   not allowed. Typevars can vary over only types, never over values.

Parameters at runtime
'''''''''''''''''''''

The set of allowable parameters for ``Literal[...]`` is currently intentionally
very small. However, we may want to extend the ways in which we can use
``Literal[...]`` in the future. To help us retain this flexibility, the
actual implementation of ``typing.Literal`` will perform *no* checks on
any parameters provided at runtime. For example::

   def my_function(x: Literal[1 + 2]) -> None:
       pass
       
   x: Literal = 3
   y: Literal[my_function] = my_funcion

The type checker should reject this program: all three uses of
``Literal`` are *invalid* according to this spec. However, Python itself
should execute this program with no errors.

Literals, enums, and forward references
'''''''''''''''''''''''''''''''''''''''

One potential ambiguity is between literal strings and forward
references to literal enum members. For example, suppose we have the
type ``Literal["Color.RED"]``. Does this literal type
contain a string literal or a forward reference to some ``Color.RED``
enum member?

In cases like these, we always assume the user meant to construct a
literal string. If the user wants a forward reference, they must wrap
the entire literal type in a string -- e.g. ``Literal[Color.RED]``.

The other alternative is to just not allow literal enums and avoid the
ambiguity altogether, but it seems a shame to give them up.

Literals, enums, and Any
''''''''''''''''''''''''

Another ambiguity is when the user attempts to use some expression that
is meant to be an enum but is actually of type ‘Any’. For example,
suppose a user attempts to import an enum from a package with no type hints::

   from typing import Literal
   from lib_with_no_types import SomeEnum  # SomeEnum has type 'Any'!

   # Signature is equivalent to `func(x: Literal[Any]) -> None`
   # due to the bad import
   def func(x: Literal[SomeEnum.FOO]) -> None: pass

Normally, the type checker would be fine with ``func``: it's usually safe to
substitute ``Any`` anywhere a type is expected.

However, in this case the type checker should report an error: types like
``Literal[Any]`` are currently considered illegal. Although ``Any`` can
serve as a placeholder for any arbitrary *type*, it is **not** allowed to
serve as a placeholder for any arbitrary *value*.

This decision is provisional and may be changed at a future date.

Inferring types for literal expressions
---------------------------------------

This section describes how to infer the correct type for literal expressions.
E.g. under what circumstances should literal expressions like ``"foo"``
have an inferred type of ``Literal["foo"]`` vs ``str``?

In general, type checkers are expected to be conservative and bias
towards inferring standard types like ``str``. Type checkers should
infer ``Literal[...]`` only in context where a Literal type is
explicitly requested.

Variable assignment
'''''''''''''''''''

When assigning a literal expression to an unannotated variable, the
inferred type of the variable is the original base type, not ``Literal[...]``.
For example::

   foo = "hello"
   reveal_type(foo)   # Revealed type is 'str'

This helps ensure we don't break the semantics of any existing code.

If the user wants ``foo`` to have a literal type, they must 
explicitly add an annotation::

   foo: Literal["hello"] = "hello"
   reveal_types(foo)   # Revealed type is 'Literal["hello"]'

Or alternatively, use the ``Final`` qualifier::

   foo: Final = "hello"
   reveal_types(foo)   # Revealed type is 'Final[Literal["hello"]]'

The ``Final`` qualifier will automatically infer a ``Literal`` type in
an assignment if the LHS is a literal expression, or an expression of
type ``Literal[…]``.

**TODO:** Link to the PEP draft for the ``Final`` qualifier once it's ready.

**Note 1:** A potential third way of declaring a Literal might be to 
try using ``Literal`` as a qualifier::

   foo: Literal = "hello"   # Illegal!

Although this looks reasonable, we feel type checkers should *reject*
constructs like these: while ``Final`` and ``ClassVar`` are *qualifiers*
and so infer their parameters, ``Literal`` is a *type* and so should not.

**Note 2:** It may sometimes be possible to use the broader context
to determine whether some variable should have a Literal type or not.
For example, in the following function, ``foo`` is only ever used as
an input to a function that expects ``Literal["blah"]`` which means
it’s theoretically possible to infer that foo has type ``Literal["blah"]``::

   def expects_blah(x: Literal["blah"]) -> None: ...

   def test() -> None:
       foo = "blah"
       expects_blah(foo)

This PEP proposes that type checkers are **not** expected to handle these
cases: it is ok to infer that ``foo`` has type ``str``.

However, it's an open question whether type checkers are permitted to *try*
handling these more complex cases on a best-effort basis. That is, are
type checkers *obligated* to infer that ``foo`` has type ``str``?

Type inference inside calls
'''''''''''''''''''''''''''

When a literal is used inside of a function call, it will be inferred
as either the original type or the Literal type based on context. For
example, the following snippet should be legal::

   def expects_str(x: str) -> None: ...
   def expects_literal(x: Literal["foo"]) -> None: ...

   # Legal: "foo" is inferred to be of type 'str'
   expects_str("foo")

   # Legal: "foo" is inferred to be of type 'Literal["foo"]'
   expects_literal("foo")

However, non-literal expressions in general will not automatically be inferred
to be literals. For example::

   def expects_literal(x: Literal["foo"]) -> None: ...

   def runner(my_str: str) -> None:
       # ILLEGAL: str is not a subclass of Literal["foo"]
       expects_literal(my_str)

**Note:** If the user wants their API to support accepting both literals
*and* the original type -- perhaps for legacy purposes -- they should
implement a fallback overload. See `Interactions with overloads`_.

Miscellaneous interactions
--------------------------

This section discusses how literal types interact with other existing types.

Intelligent indexing of structured data: Interactions with TypedDict, Tuple, NamedTuples, and getattr
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

The type checker should support "intelligently indexing" into structured
types like TypedDicts, NamedTuple, and classes when using string and int
literal keys. (This is not an exhaustive list.)

For example, type checkers should infer the correct value type when
indexing into a TypedDict using a string literal that corresponds to
one of the available keys:

   Foo = TypedDict('Foo', {
       'key1': int,
       'key2': str,
       'key3': List[bool],
   })

   a: Final = "key1"
   b: Final = "some other string"

   f: Foo
   reveal_type(f[a])  # Revealed type is 'int'
   f[b]               # Error: 'Foo' does not contain a key named 'some other string'

We require similar behavior when indexing into a tuple or named tuple::

   a: Final = 0
   b: Final = 5

   some_tuple: Tuple[int, str, List[bool]] = (3, "abc", [True, False])
   reveal_type(some_tuple[a])   # Revealed type is 'int'
   some_tuple[b]                # Error: 5 is not a valid index into the tuple

...and when using functions like getattr::

   class Test:
       def __init__(self, param: int) -> None:
           self.myfield = param
       
       def mymethod(self, val: int) -> str: ...
       
   a: Final = "myfield"
   b: Final = "mymethod"
   c: Final = "blah"

   t = Test()
   reveal_type(getattr(t, a))  # Revealed type is 'int'
   reveal_type(getattr(t, b))  # Revealed type is 'Callable[[int], str]'
   getattr(t, c)               # Error: 'Test' does not have attribute named 'blah'

These interactions will most likely need to be added to type checkers on
an ad-hoc basis. This is a little unfortunate: it would have been nice to
unify these interactions by adding  something like TypeScript’s
`index types <typescript-index-types_>`_ and ``keyof`` operator, which lets
you encode the idea that some key (e.g. a literal string) is a member of
some object.

We currently do not plan on adding a similar concept to Python. Python
has many different kinds of structured data beyond just objects
(classes, objects, TypedDict, tuples, NamedTuples…) and it’s unclear
what the ramifications of attempting to unify all these different
concepts using this idea might be. It may be worth attempting to
unify this behavior in the future, but probably not as a part of this PEP.

Interactions with overloads
'''''''''''''''''''''''''''

Literal types and overloads do not need to interact in any
particularly special way: the existing rules should work fine.

However, one important use case type checkers must take care to
support is the ability a *fallback* when the user is not using literal
types. For example, consider ``open``::

   _PathType = Union[str, bytes, int]

   @overload
   def open(path: _PathType, 
            mode: Literal["r", "w", "a", "x", "r+", "w+", "a+", "x+"],
            ) -> IO[Text]: ...
   @overload
   def open(path: _PathType, 
            mode: Literal["rb", "wb", "ab", "xb", "r+b", "w+b", "a+b", "x+b"],
            ) -> IO[bytes]: ...

   # Fallback overload for when the user isn't using literal types
   @overload
   def open(path: _PathType, mode: str) -> IO[Any]: ...

If we change the signature of ``open`` to use just the first two overloads,
we would break any code that does not pass in a literal string expression.
For example, code like this would be broken::

   mode: str = pick_file_mode(...)
   with open(path, mode) as f:
       # f should continue to be of type IO[Any] here

A little more broadly: we propose adding a policy to typeshed that
mandates that whenever we add literal types to some existing API, we also
always include a fallback overload to maintain backwards-compatibility.

Interactions with generics
''''''''''''''''''''''''''

Types like ``Literal[3]`` are meant to be just plain old subclasses of
``int``. This means you can use types like ``Literal[3]`` anywhere
you could use normal types, such as with generics.

For example, suppose we want to construct a type representing a
2-dimensional Matrix which can be parameterized by two literal ints
representing the number of rows and columns respectively. Such a type
could be built using the existing generics system like so::

   A = TypeVar('A', bound=int)
   B = TypeVar('B', bound=int)
   C = TypeVar('C', bound=int)

   # A simplified definition for Matrix[row, column]
   class Matrix(Generic[A, B]):
       def __init__(self, elements: List[List[int]]) -> None: ...
       def __add__(self, other: Matrix[A, B]) -> Matrix[A, B]: ...
       def __matmul__(self, other: Matrix[B, C]) -> Matrix[A, C]: ...
       def transpose(self) -> Matrix[B, A]: ...
       
   Foo: Matrix[Literal[2], Literal[3]] = Matrix(...)
   Bar: Matrix[Literal[3], Literal[7]] = Matrix(...)

   reveal_type(Foo @ Bar)  # Revealed type is Matrix[Literal[2], Literal[7]]
   Bar @ Foo               # Error, Foo doesn't match expected type Matrix[Literal[7], Literal[int]]

This class definition is not perfect: it would not prohibit users from
constructing less precise types like ``Matrix[int, int]`` due to the
typevar bound, for example.

We considered several different proposals for addressing this gap 
but ultimately rejected all of them and decided to defer the problem
of integer generics to a later date. See `Rejected or out-of-scope ideas`_

Interactions with asserts and other checks
''''''''''''''''''''''''''''''''''''''''''

Type checkers should narrow the type of variables when they are compared
directly against other literal types. For example::

   def foo(x: str) -> None:
       if x == "foo":
           # Type checker should narrow 'x' to "foo" here
           expects_foo(x)
       
       # Similarly, type checker should narrow 'x' to "bar" here
       assert x == "bar"
       expects_bar(x)

Type checkers may optionally perform additional analysis and narrowing.

**Note:** The exact details of this section may be subject to change.

Interactions with Final types
'''''''''''''''''''''''''''''

The interactions between final and literal types were previously
mentioned above, but to reiterate: if a variable is annotated as
``Final`` and has a literal expression on the RHS, the inferred type
should be Literal::

   root_id: Final = 1

   # Revealed type should be 'Final[Literal[1]]' or something similar
   reveal_type(root_id)

   # The types of 'root_id' and 'root_id_2' should be identical
   root_id_2: Final[Literal[1]] = 1

**TODO:** Cross-link to draft PEP for 'Final' once it's ready

Rejected or out-of-scope ideas
==============================

This section outlines some potential features that are explicitly out-of-scope.

True dependent types/integer generics
-------------------------------------

This proposal is essentially describing adding a very simplified
dependent type system to the PEP 484 ecosystem. One obvious extension
is to implement a full-fledged dependent type system that let users
predicate types based on their values in arbitrary ways. This would
let us write signatures like the below::

   # A vector has length 'n', containing elements of type 'T'
   class Vector(Generic[N, T]): ...

   # The type checker will statically verify our function genuinely does 
   # construct a vector that is equal in length to "len(vec1) + len(vec2)"
   # and will throw an error if it does not.
   def vector_concat(vec1: Vector[A, T], vec2: Vector[B, T]) -> Vector[A + B, T]:
       # ...snip...

At the very least, it would be useful to add some form of integer generics.

Although such a type system would certainly be useful, it’s out-of-scope
for this PEP: it would require a far more substantial amount of implementation work,
discussion, and research to complete compared to the current proposal.

It's entirely possible that we'll circle back and revisit this topic in the future:
we very likely will need some form of dependent typing along with other extensions
like variadic generics to support popular libraries like numpy.

This PEP should be seen as one of the stepping stones towards this goal.

Adding more concise syntax for literal types
--------------------------------------------

One objection to this PEP is that having to explicitly write ``Literal[...]`` feels
verbose. For example, instead of writing::

   def foobar(arg1: Literal[1], arg2: Literal[True]) -> None:
       pass

...it would be nice to instead write::

   def foobar(arg1: 1, arg2: True) -> None:
       pass

Unfortunately, these abbreviations simply will not work with the
existing implementation of ``typing`` at runtime. For example, the
following snippet crashes when run using Python 3.7::

   from typing import Tuple

   # Supposed to accept tuple containing the literals 1 and 2
   def foo(x: Tuple[1, 2]) -> None:
       pass

Running this yields the following exception::

   TypeError: Tuple[t0, t1, …]: each t must be a type. Got 1.

We don’t want users to have to memorize exactly when it’s ok to elide ``Literal``,
so we require ``Literal`` to always be present.

Backwards compatibility
=======================

Once this PEP is accepted, the ``Literal`` type will need to be backported for
Python versions that come bundled with older versions of the ``typing`` module.
We plan to do this by adding ``Literal`` to the ``typing_extensions`` 3rd party
module, along with the other backported types.

There should be no backwards compatibility issues apart from this.

Related work
============

This proposal was written based on the discussion that took place in the
following threads:

-  `Check that literals belong to/are excluded from a set of values <typing-discussion_>`_

-  `Simple dependent types <mypy-discussion_>`_

-  `Typing for multi-dimensional arrays <arrays-discussion_>`_

The overall design of this proposal also ended up converging into
something similar to how 
`literal types are handled in TypeScript <typescript-literal-types_>`_.

.. _typing-discussion: https://github.com/python/typing/issues/478

.. _mypy-discussion: https://github.com/python/mypy/issues/3062

.. _arrays-discussion: https://github.com/python/typing/issues/513

.. _typescript-literal-types: https://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal_types

.. _typescript-index-types: https://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

